1、GCC是Linux下的编译工具集，是GNU Compiler Collection的缩写，包含gcc，g++等编译器。

2、GCC编译器对程序的编译分为四个阶段：

1️⃣预处理：这个阶段需要GCC调用预处理器来完成，主要做三件事：展开头文件、宏替换、去掉注释行。最终得到的还是源文件，文本格式。

这一步使用参数-E，预处理后得到.i后缀的文件。

2️⃣编译：这个阶段需要GCC调用编译器对文件进行编译，最终得到一个汇编文件。

这一步使用参数-S，编译后得到.s后缀的文件。

3️⃣汇编：这个阶段需要GCC调用汇编器对文件进行汇编，最终得到一个二进制文件。

这一步使用参数-c，汇编后得到.o后缀的文件。

4️⃣链接：这个阶段需要GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件。

3、上述步骤举例如下，例如要编译test.c文件：

1️⃣预处理：

```
gcc -E test.c -o test.i
```

-o表示生成文件的名字是什么。

2️⃣编译：

```
gcc -S test.i -o test.s
```

3️⃣汇编：

```
gcc -c test.s -o test.o
```

4️⃣链接：

```
gcc test.o -o test
```

最后一步不需要参数，直接就生成了可执行程序test。

然后就可以直接运行了：

```
./test
```

4、也可以直接第四步，前面其实都可以省略的：

```
gcc test.c -o aa
```

直接就生成了可执行程序aa

也可以不指定可执行程序的名称，系统会自动生成一个可执行程序a.out:

```
gcc test.c
```

5、gcc的-I参数：

```
gcc *.c -I include
```

表示编译当前目录下的所有.c文件，并指定了头文件所在的位置，即让编译器去include/目录里面寻找头文件。

6、不论是gcc还是g++都可以编译c程序，编译程序的规则和参数都相同。

g++可以直接编译C++程序，gcc编译c++程序需要添加额外参数-lstdc++，因为gcc要链接标准c++库需要添加参数-lstdc++。

gcc和g++都可以定义__cplusplus宏。

例如：编译c程序：

```
gcc test.c -o test
g++ test.c -o test
```

编译c++程序：

```
gcc test.cpp -lstdc++ -o test
g++ test.cpp -o test
```

7、在linux中，想要生成静态库，需要先使用参数-c对源文件进行汇编操作，得到二进制.o文件，然后再通过ar工具将目标文件打包就可以得到静态库文件了。

其中，在使用ar工具创建静态库时需要三个参数：

参数c：创建一个库，不管库是否存在，都将创建。

参数s：创建目标文件索引，这在创建较大的库时能加快时间。

参数r：在库中插入模块(即.o文件)，如果插入的模块在库中有同名的，则替换之。默认新的成员添加在库的结尾处。

语法格式为：

```
ar rcs 静态库名称(libxxx.a) 原材料(*.o)
```

举例如下:

```
ar rcs libcalc.a *.o
```

8、静态库制作完成之后要使用，首先需要将libcalc.a和haed.h发布出去，head.h相当于对静态库的声明。

通过main.c使用静态库，生成可执行文件calc：

```
gcc main.c -L ./ -l calc -o calc
```

注意此时写库的名字的时候要掐头去尾，即去掉前面的lib和后面的.a。

-l参数表示在程序编译的时候，指定使用的库；

-L参数表示指定编译的时候，搜索的库的路径。

9、在linux中，静态库以lib为前缀，.a为后缀，例如libxxx.a；动态库以lib为前缀，.so为后缀，例如libxxx.so。

在Windows中，静态库以lib为前缀，.lib为后缀，例如libxxx.lib；动态库以lib为前缀，.dll为后缀，例如libxxx.dll。

10、生成动态链接库的具体步骤如下：

1️⃣将源文件进行汇编操作(使用-c参数)，除此之外还需要添加额外参数 -fpic:

```
gcc *.c -c -fpic
```

2️⃣将得到的.o文件打包成动态库，还是使用gcc，同时使用-shared参数指定生成动态库：

```
gcc -shared *.o -o libxxx.so
```

3️⃣发布动态库和头文件：

提供头文件xxx.h和动态库libxxx.so即可。

例如，用main.c测试动态库libcalc.so，生成可执行程序app：

```
gcc main.c -L ./ -l calc -o app
```

执行一下：

```
./app
```

