# 1、简单工厂模式

## 概念

简单工厂模式是一种创建型设计模式，它定义了一个工厂类，用于创建不同类型的对象。简单工厂模式通过工厂类封装对象的创建过程，将对象的实例化过程从使用者代码中解耦出来。

## 特点

简单工厂模式有一个工厂类负责根据传入的参数决定实例化哪个类。

客户端代码通过传入不同的参数，来获得不同类型的对象，避免了直接使用 new来实例化对象。

## 示例

假设我们有一个产品类 Product，它有两种子类 ConcreteProductA和 ConcreteProductB。我们可以使用一个工厂类 ProductFactory 来根据传入的类型创建不同的产品：

```c++
// 抽象产品类
class Product {
public:
    virtual ~Product() = default;
    virtual void use() = 0;
};

// 具体产品A
class ConcreteProductA : public Product {
public:
    void use() override {
        std::cout << "Using ConcreteProductA" << std::endl;
    }
};

// 具体产品B
class ConcreteProductB : public Product {
public:
    void use() override {
        std::cout << "Using ConcreteProductB" << std::endl;
    }
};

// 工厂类
class ProductFactory {
public:
    // 根据传入的类型来创建不同的产品
    static std::unique_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_unique<ConcreteProductA>();
        } else if (type == "B") {
            return std::make_unique<ConcreteProductB>();
        }
        return nullptr; // 未知类型返回nullptr
    }
};

int main() {
    // 通过工厂创建产品
    auto productA = ProductFactory::createProduct("A");
    productA->use();

    auto productB = ProductFactory::createProduct("B");
    productB->use();

    return 0;
}

```

# 2、策略模式

## 概念

策略模式是一种行为设计模式，旨在定义一系列算法，并将每一个算法封装起来，使它们可以互换。策略模式允许客户端在不修改代码的情况下选择不同的算法。

## 关键点

**Context（上下文）**：维护一个对策略对象的引用，并可以通过它来切换策略。

**Strategy（策略）**：定义了算法的接口，所有具体的策略都实现该接口。

**ConcreteStrategy（具体策略）**：实现了具体的算法。

## 示例

假设我们要设计一个简单的排序算法，用户可以选择不同的排序策略（如快速排序、冒泡排序、插入排序），代码中**BubbleSort** 和 **QuickSort** 是两个具体的策略类，分别实现了冒泡排序和快速排序；上下文类 `SortContext` 持有一个 `SortStrategy` 的指针，并提供了一个 `executeSort()` 方法来调用策略的 `sort()` 方法，此外，还提供了一个 `setStrategy()` 方法用来动态改变策略。

```c++
// 策略接口
class SortStrategy {
public:
    virtual ~SortStrategy() {}
    virtual void sort(std::vector<int>& data) const = 0;
};

// 具体策略：冒泡排序
class BubbleSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) const override {
        std::cout << "Using Bubble Sort\n";
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - 1 - i; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
};

// 具体策略：快速排序
class QuickSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) const override {
        std::cout << "Using Quick Sort\n";
        quickSortHelper(data, 0, data.size() - 1);
    }

private:
    void quickSortHelper(std::vector<int>& data, int low, int high) const {
        if (low < high) {
            int pivot = partition(data, low, high);
            quickSortHelper(data, low, pivot - 1);
            quickSortHelper(data, pivot + 1, high);
        }
    }

    int partition(std::vector<int>& data, int low, int high) const {
        int pivot = data[high];
        int i = low - 1;
        for (int j = low; j < high; ++j) {
            if (data[j] < pivot) {
                ++i;
                std::swap(data[i], data[j]);
            }
        }
        std::swap(data[i + 1], data[high]);
        return i + 1;
    }
};

// 上下文类
class SortContext {
private:
    SortStrategy* strategy;

public:
    SortContext(SortStrategy* strategy) : strategy(strategy) {}

    void setStrategy(SortStrategy* newStrategy) {
        strategy = newStrategy;
    }

    void executeSort(std::vector<int>& data) const {
        strategy->sort(data);
    }
};

// 测试代码
int main() {
    std::vector<int> data = {5, 3, 8, 6, 2, 7};

    // 使用冒泡排序策略
    SortContext context(new BubbleSort());
    context.executeSort(data);
    
    // 打印排序后的数据
    for (int num : data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // 使用快速排序策略
    data = {5, 3, 8, 6, 2, 7};
    context.setStrategy(new QuickSort());
    context.executeSort(data);
    
    // 打印排序后的数据
    for (int num : data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

# 3、策略模式和简单工厂模式结合使用

在将这两种模式结合使用时，简单工厂可以用于创建不同的策略对象，策略模式负责执行具体的算法。

假设我们想要设计一个支持不同排序算法（如冒泡排序、快速排序、选择排序）的系统，其中，简单工厂模式用于根据用户输入选择排序算法，而策略模式则负责封装不同的排序算法。

```c++
// 策略接口
class SortStrategy {
public:
    virtual ~SortStrategy() {}
    virtual void sort(std::vector<int>& data) const = 0;
};

// 具体策略：冒泡排序
class BubbleSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) const override {
        std::cout << "Using Bubble Sort\n";
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - 1 - i; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
};

// 具体策略：快速排序
class QuickSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) const override {
        std::cout << "Using Quick Sort\n";
        quickSortHelper(data, 0, data.size() - 1);
    }

private:
    void quickSortHelper(std::vector<int>& data, int low, int high) const {
        if (low < high) {
            int pivot = partition(data, low, high);
            quickSortHelper(data, low, pivot - 1);
            quickSortHelper(data, pivot + 1, high);
        }
    }

    int partition(std::vector<int>& data, int low, int high) const {
        int pivot = data[high];
        int i = low - 1;
        for (int j = low; j < high; ++j) {
            if (data[j] < pivot) {
                ++i;
                std::swap(data[i], data[j]);
            }
        }
        std::swap(data[i + 1], data[high]);
        return i + 1;
    }
};

// 具体策略：选择排序
class SelectionSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) const override {
        std::cout << "Using Selection Sort\n";
        for (size_t i = 0; i < data.size(); ++i) {
            size_t minIndex = i;
            for (size_t j = i + 1; j < data.size(); ++j) {
                if (data[j] < data[minIndex]) {
                    minIndex = j;
                }
            }
            std::swap(data[i], data[minIndex]);
        }
    }
};

// 简单工厂：根据用户输入返回不同的排序策略
class SortStrategyFactory {
public:
    static SortStrategy* createSortStrategy(const std::string& type) {
        if (type == "bubble") {
            return new BubbleSort();
        } else if (type == "quick") {
            return new QuickSort();
        } else if (type == "selection") {
            return new SelectionSort();
        } else {
            return nullptr; // 未知排序类型
        }
    }
};

// 上下文类
class SortContext {
private:
    SortStrategy* strategy;

public:
    // 构造函数，接受策略类型的字符串并根据字符串选择具体策略
    SortContext(const std::string& strategyType) {
        if (strategyType == "bubble") {
            strategy = new BubbleSort();
        } else if (strategyType == "quick") {
            strategy = new QuickSort();
        } else if (strategyType == "selection") {
            strategy = new SelectionSort();
        } else {
            strategy = nullptr;  // 如果未识别的策略类型，则为 nullptr
            std::cout << "Unknown strategy type!" << std::endl;
        }
    }

    // 允许修改策略
    void setStrategy(const std::string& strategyType) {
        // 删除旧的策略
        delete strategy;

        // 根据新的策略类型创建新的策略
        if (strategyType == "bubble") {
            strategy = new BubbleSort();
        } else if (strategyType == "quick") {
            strategy = new QuickSort();
        } else if (strategyType == "selection") {
            strategy = new SelectionSort();
        } else {
            strategy = nullptr;  // 如果未识别的策略类型，则为 nullptr
            std::cout << "Unknown strategy type!" << std::endl;
        }
    }

    void executeSort(std::vector<int>& data) const {
        if (strategy != nullptr) {
            strategy->sort(data);
        } else {
            std::cout << "No valid strategy set!" << std::endl;
        }
    }

    // 析构函数，删除策略对象
    ~SortContext() {
        delete strategy;
    }
};

// 客户端代码
int main() {
    std::vector<int> data = {5, 3, 8, 6, 2, 7};

    // 客户端通过字符串选择排序策略
    SortContext context("quick");  // 可以选择 "bubble", "quick", "selection"

    // 执行排序
    context.executeSort(data);

    // 打印排序后的数据
    for (int num : data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // 可以动态改变策略
    context.setStrategy("bubble");
    data = {5, 3, 8, 6, 2, 7};
    context.executeSort(data);
    
    // 打印排序后的数据
    for (int num : data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

二者结合之后客户端只需要认识SortContext上下文类即可，不需要认识其他类，降低了耦合度。

# 4、单一职责原则

## 定义

单一职责原则的核心思想是：一个类应该只有一个职责，并且该类应该仅仅负责与该职责相关的功能。即，类的变化应该只有一个原因，类的设计应该聚焦于完成一项特定的任务，而不应该承担多个不相关的责任。

## 优点

**易于维护**：如果一个类承担多个职责，那么当系统发生变化时，这些职责可能会相互影响，增加了修改和维护的复杂性。如果类只有一个职责，修改时只会影响到这一职责，从而使得维护工作变得更容易。

**提高可理解性**：每个类只关注单一职责时，类的功能变得更加明确，易于理解和使用。

**增强可扩展性**：当类的职责明确时，功能扩展时不容易影响现有的功能。新功能可以通过添加新的类来实现，而不必修改现有的类。

**测试更容易**：如果一个类的功能单一，针对这个类的单元测试会更清晰，也更容易进行。

# 5、开放-封闭原则

## 核心思想

**对扩展开放（Open for extension）**：系统应当能够在不修改现有代码的情况下，通过增加新功能来扩展系统。

**对修改封闭（Closed for modification）**：一旦系统的某部分被实现并且经过测试，它就不应该被修改。任何新的功能都应该通过扩展现有代码来实现，而不是直接修改原有的代码。

## 重要性

**提高可维护性**：遵循这一原则的设计可以使得系统在增加新功能时不需要改变原有的代码，从而降低了修改现有功能时出现错误的风险。

**增强灵活性和扩展性**：开发人员可以在不影响原有系统的基础上，通过扩展现有的功能来满足新需求。

**减少错误**：如果修改原有代码，每次更改都有可能引入新的错误或冲突。通过扩展现有功能而非修改现有代码，可以减少错误的发生。

## 如何实现开放-封闭原则

1️⃣**抽象化**：通过抽象化（如使用接口或抽象类）来隔离系统的核心功能和扩展部分。新功能的增加只需要实现这些接口或继承这些抽象类，而不需要修改原有实现。

2️⃣**使用设计模式**：许多设计模式（如策略模式、模板方法模式、装饰器模式等）都遵循开放-封闭原则，通过允许系统在不修改现有代码的基础上进行扩展。

## 举例

首先，我们定义一个抽象基类 `PaymentMethod`，它作为所有支付方式的通用接口；然后创建多个类来实现这个接口，每个类代表不同的支付方式。

```c++
// 抽象基类，表示支付方式
class PaymentMethod {
public:
    virtual void pay(double amount) = 0;  // 纯虚函数，要求派生类实现
    virtual ~PaymentMethod() {}  // 虚析构函数，保证多态删除
};

// 信用卡支付方式
class CreditCardPayment : public PaymentMethod {
public:
    void pay(double amount) override {
        cout << "Paying " << amount << " via Credit Card" << endl;
    }
};

// 支付宝支付方式
class AlipayPayment : public PaymentMethod {
public:
    void pay(double amount) override {
        cout << "Paying " << amount << " via Alipay" << endl;
    }
};

// 微信支付方式
class WeChatPayment : public PaymentMethod {
public:
    void pay(double amount) override {
        cout << "Paying " << amount << " via WeChat Pay" << endl;
    }
};

int main() {
    // 这里我们使用指向基类的指针来引用不同的支付方式
    PaymentMethod* payment;

    // 使用信用卡支付
    payment = new CreditCardPayment();
    payment->pay(100.0);  // 输出：Paying 100 via Credit Card

    // 使用支付宝支付
    payment = new AlipayPayment();
    payment->pay(150.0);  // 输出：Paying 150 via Alipay

    // 使用微信支付
    payment = new WeChatPayment();
    payment->pay(200.0);  // 输出：Paying 200 via WeChat Pay

    // 释放内存
    delete payment;

    return 0;
}
```

在客户端代码中，创建支付对象时不需要知道具体支付方式的实现，只需要通过多态来调用 `pay` 方法。这体现了“对扩展开放，对修改封闭”的设计原则。如果我们想添加新的支付方式，只需要创建新的支付方式类，而不需要修改现有代码。

```c++
int main() {
    // 这里我们使用指向基类的指针来引用不同的支付方式
    PaymentMethod* payment;

    // 使用信用卡支付
    payment = new CreditCardPayment();
    payment->pay(100.0);  // 输出：Paying 100 via Credit Card

    // 使用支付宝支付
    payment = new AlipayPayment();
    payment->pay(150.0);  // 输出：Paying 150 via Alipay

    // 使用微信支付
    payment = new WeChatPayment();
    payment->pay(200.0);  // 输出：Paying 200 via WeChat Pay

    // 释放内存
    delete payment;

    return 0;
}
```

# 6、依赖倒转原则

## 原则解释

传统的设计中，程序模块往往是“自上而下”的依赖结构，即高层模块（负责主要逻辑的模块）依赖于低层模块（具体实现细节的模块）。这种设计会导致模块间的紧耦合，造成系统的灵活性差、扩展性低。

依赖倒转原则提出了改进的方法：

**高层模块（业务逻辑）不应该依赖于低层模块（实现细节）**：高层模块和低层模块都应该依赖于抽象（接口或抽象类）。

**抽象（接口或抽象类）不应该依赖于具体实现**：相反，具体实现应该依赖于抽象。

## 作用

**减少模块之间的耦合**，使得高层模块和低层模块可以独立变化。

**提高代码的可扩展性和灵活性**，当实现细节发生变化时，不会影响到依赖它的高层模块。

**更容易进行单元测试**，因为高层模块依赖的是抽象，而不是具体的实现，所以可以方便地替换实现以进行测试。

## 举例

假设我们在开发一个消息发送系统，代码如下：

```c++
class EmailSender {
public:
    void sendEmail(const std::string& message) {
        std::cout << "Sending Email: " << message << std::endl;
    }
};

class Notification {
    EmailSender emailSender;
public:
    void send(const std::string& message) {
        emailSender.sendEmail(message);
    }
};
```

这种设计使得 `Notification` 类和 `EmailSender` 类耦合在一起，我们想要改变消息发送方式的话就需要改动 `Notification` 类的代码，不符合依赖倒转原则。

此时我们可以引入一个接口 `MessageSenderInterface`，让 `Notification` 依赖于该接口，而不是具体的实现：

```c++
// 抽象接口
class MessageSenderInterface {
public:
    virtual void sendMessage(const std::string& message) = 0;
    virtual ~MessageSenderInterface() = default;
};

// 具体实现1：发送电子邮件
class EmailSender : public MessageSenderInterface {
public:
    void sendMessage(const std::string& message) override {
        std::cout << "Sending Email: " << message << std::endl;
    }
};

// 具体实现2：发送短信
class SMSSender : public MessageSenderInterface {
public:
    void sendMessage(const std::string& message) override {
        std::cout << "Sending SMS: " << message << std::endl;
    }
};

// Notification 类依赖于接口而非具体实现
class Notification {
    MessageSenderInterface* messageSender;
public:
    Notification(MessageSenderInterface* sender) : messageSender(sender) {}

    void send(const std::string& message) {
        messageSender->sendMessage(message);
    }
};
```

在这里，`Notification` 类依赖于 `MessageSenderInterface` 接口，而不是具体的 `EmailSender` 或 `SMSSender` 类。这样，如果我们想要更换消息发送方式（比如从电子邮件改成短信），只需要传入不同的实现即可，而不需要修改 `Notification` 类的代码。

依赖倒转原则的核心在于高层模块和低层模块都只**依赖于抽象而不是具体实现**，这就使得高层模块和低层模块都很容易被复用。

# 7、里氏代换原则

## 核心思想

**子类必须能够替换掉父类，并且让程序的行为保持不变**。

## 原则解释

如果一个程序使用的是父类的对象，那么在不修改程序的前提下，用子类对象替换父类对象，程序的行为依然是正确的。这意味着子类在行为上应该兼容父类，保证子类能完全替换父类而不产生错误或异常。

换句话说，**在继承关系中，子类应当扩展父类的功能，而不是破坏父类的功能**。子类继承父类时，不仅要实现父类的所有功能，还要保证不改变父类原有的行为。父类中定义的方法行为和约束条件，子类必须遵守，不能随意修改。

## 举例

定义矩形类Rectangle，然后定义一个它的字类正方形类squre：

```c++
class Rectangle {
protected:
    int width, height;
public:
    void setWidth(int w) { width = w; }
    void setHeight(int h) { height = h; }
    int getWidth() const { return width; }
    int getHeight() const { return height; }
    int getArea() const { return width * height; }
};

class Square : public Rectangle {
public:
    void setWidth(int w) {
        width = w;
        height = w;
    }
    void setHeight(int h) {
        width = h;
        height = h;
    }
};

```

在上面的例子中，`Square` 类违背了里氏代换原则。在 `Square` 中，`setWidth` 和 `setHeight` 是耦合的：调用 `setWidth` 时，高度也会随之改变；同样，调用 `setHeight` 时，宽度也会随之改变。而矩形类中则不是如此，正方形类隐形添加了长等于宽的约束，使得直接拿Squre代替Rectangle类会很奇怪，修改长或者宽导致二者都发生了变化。	

# 8、装饰模式

## 概念

**装饰模式（Decorator Pattern）** 是一种结构型设计模式，它允许在不修改原始对象的情况下，为对象添加新的功能。装饰模式通过将对象包装在一个装饰器类中，使得装饰器类可以动态地为对象添加职责或行为。装饰模式的核心思想是**用一个或多个装饰对象“包装”原始对象，以动态地扩展功能**。

## 特点

**动态扩展对象的功能**：与继承不同，装饰模式允许在运行时根据需要为对象添加不同的功能，而不必为每个新功能创建子类。

**遵循开放/封闭原则**：装饰模式不会修改原始类的代码，而是通过组合的方式扩展对象的功能，使类对扩展开放、对修改封闭。

**装饰器和被装饰对象具有相同的接口**：装饰器类和被装饰的对象都实现相同的接口，因此它们可以互相替换。

## 结构和组成

**抽象组件（Component）**：定义对象的接口，可以是抽象类或接口，确保装饰器和被装饰对象具有一致的接口。

**具体组件（Concrete Component）**：实现了组件接口的具体类，即被装饰的原始对象。

**装饰器基类（Decorator）**：实现组件接口的类，内部持有一个组件的引用，所有装饰器类都继承这个抽象类。

**具体装饰器（Concrete Decorator）**：继承自装饰器类，为组件添加具体的功能或行为。

## 举例

假设我们有一个 `Coffee` 类表示咖啡，可以通过装饰器模式为咖啡添加各种调料（如糖、牛奶等），使其具有不同的组合特性：

1️⃣定义抽象组件接口(抽象coffee类）：定义了 `getDescription` 和 `cost` 方法，为具体组件和装饰器提供一致的接口。

```c++
// 抽象组件
class Coffee {
public:
    virtual ~Coffee() = default;
    virtual std::string getDescription() const = 0;
    virtual double cost() const = 0;
};

```

2️⃣定义具体组件(Simple咖啡类)：实现了基础咖啡的功能。

```c++
// 具体组件：基础咖啡
class SimpleCoffee : public Coffee {
public:
    std::string getDescription() const override {
        return "Simple Coffee";
    }
    
    double cost() const override {
        return 5.0; // 基础咖啡的价格
    }
};
```

3️⃣定义装饰器基类：持有一个 `Coffee` 对象的引用，允许在装饰器类中动态组合不同的功能。

```c++
// 装饰器基类
class CoffeeDecorator : public Coffee {
protected:
    Coffee* coffee; // 持有一个组件的引用
public:
    CoffeeDecorator(Coffee* c) : coffee(c) {}
    
    std::string getDescription() const override {
        return coffee->getDescription();
    }
    
    double cost() const override {
        return coffee->cost();
    }
};
```

4️⃣定义具体装饰器：`SugarDecorator` 和 `MilkDecorator` 分别为 `Coffee` 添加了糖和牛奶的功能，通过覆盖 `getDescription` 和 `cost` 方法实现额外的行为。

```c++
// 具体装饰器：加糖
class SugarDecorator : public CoffeeDecorator {
public:
    SugarDecorator(Coffee* c) : CoffeeDecorator(c) {}
    
    std::string getDescription() const override {
        return coffee->getDescription() + ", Sugar";
    }
    
    double cost() const override {
        return coffee->cost() + 0.5; // 加糖的额外费用
    }
};

// 具体装饰器：加牛奶
class MilkDecorator : public CoffeeDecorator {
public:
    MilkDecorator(Coffee* c) : CoffeeDecorator(c) {}
    
    std::string getDescription() const override {
        return coffee->getDescription() + ", Milk";
    }
    
    double cost() const override {
        return coffee->cost() + 1.0; // 加牛奶的额外费用
    }
};
```

5️⃣定义完之后就可以在客户端中使用装饰器模式了：

```c++
int main() {
    Coffee* coffee = new SimpleCoffee();
    std::cout << coffee->getDescription() << " costs $" << coffee->cost() << std::endl;

    // 添加糖
    coffee = new SugarDecorator(coffee);
    std::cout << coffee->getDescription() << " costs $" << coffee->cost() << std::endl;

    // 添加牛奶
    coffee = new MilkDecorator(coffee);
    std::cout << coffee->getDescription() << " costs $" << coffee->cost() << std::endl;

    delete coffee; // 释放内存
    return 0;
}
```

最后的输出为：

```c++
Simple Coffee costs $5
Simple Coffee, Sugar costs $5.5
Simple Coffee, Sugar, Milk costs $6.5
```



# 9、代理模式

## 概念

**代理模式（Proxy Pattern）** 是一种结构型设计模式，它为其他对象提供一种代理（或占位符）以控制对这个对象的访问。代理模式通过引入一个代理对象，来代替或控制对实际对象的访问。代理对象可以在不改变实际对象的情况下添加一些额外的功能，例如访问控制、延迟加载、缓存等。

## 特点

**代理对象和真实对象实现相同的接口**：代理对象对外提供与真实对象一致的接口，使得客户端可以透明地使用代理对象，而不必关心实际对象的存在。

**控制对真实对象的访问**：代理对象可以控制对实际对象的访问，在访问前后执行额外的操作。

**支持延迟加载**：可以在代理对象中延迟实例化真实对象，只有在真正需要使用时才创建真实对象。

## 分类

**远程代理（Remote Proxy）**：用于将对象放在不同的地址空间中，通过代理来隐藏这一事实。例如，RPC（远程过程调用）使用代理来访问远程服务器上的对象。

**虚拟代理（Virtual Proxy）**：用于延迟加载，控制资源的访问。当创建对象的开销较大时，可以用虚拟代理来替代真正的对象，等需要时再创建。

**保护代理（Protection Proxy）**：用于控制权限，限制客户端对对象的访问。只有满足权限的客户端才可以操作实际对象。

**智能引用代理（Smart Reference Proxy）**：在访问对象时进行额外的操作，例如引用计数、记录日志等。

## 结构

代理模式主要包含以下角色：

**抽象主题（Subject）**：定义代理类和真实类共同的接口，使得代理类和真实类可以互换。

**真实主题（Real Subject）**：实现了抽象主题接口的类，是真正的业务对象。

**代理类（Proxy）**：持有对真实主题对象的引用，并实现抽象主题接口。代理类通过调用真实主题来完成实际的功能，并可以在调用前后增加额外的行为。

## 举例

假设我们有一个大型图片文件，需要加载和显示。由于图片文件较大，加载耗时较长，因此我们可以使用代理模式，在需要时才加载图片，实现“延迟加载：

1️⃣首先定义抽象主题接口Image类：

```c++
// 抽象主题接口
class Image {
public:
    virtual void display() = 0;
    virtual ~Image() = default;
};
```

2️⃣定义真实主题Realmage类：在 `RealImage` 类中，图片在构造时会从磁盘加载，`display()` 方法会显示图片内容。

```c++
// 真实主题：实际的图片类
class RealImage : public Image {
    std::string filename;
public:
    RealImage(const std::string& file) : filename(file) {
        loadImageFromDisk();
    }

    void display() override {
        std::cout << "Displaying " << filename << std::endl;
    }

private:
    void loadImageFromDisk() {
        std::cout << "Loading " << filename << std::endl;
    }
};
```

3️⃣定义代理类ProxyImage：在 `ProxyImage` 类中，我们持有一个 `RealImage` 对象的指针。只有在调用 `display()` 时，才会真正创建 `RealImage` 实例，这样可以实现图片的延迟加载。

```c++
// 代理类：代理图片类，用于延迟加载
class ProxyImage : public Image {
    std::string filename;
    RealImage* realImage; // 指向真实的图片对象

public:
    ProxyImage(const std::string& file) : filename(file), realImage(nullptr) {}

    ~ProxyImage() {
        delete realImage;
    }

    void display() override {
        if (!realImage) {
            realImage = new RealImage(filename); // 延迟加载
        }
        realImage->display();
    }
};
```

4️⃣最后在客户端使用代理模式：

```c++
int main() {
    Image* image = new ProxyImage("test.jpg");

    // 图片不会立即加载，只有在需要显示时才加载
    image->display();
    std::cout << "--------------------" << std::endl;
    // 再次调用 display() 时，不会重新加载
    image->display();

    delete image;
    return 0;
}
```

输出结果为：

```
Loading test.jpg
Displaying test.jpg
--------------------
Displaying test.jpg
```

# 10、工厂方法模式

## 概念

工厂方法模式是一个创建型设计模式，它定义了一个用于创建对象的接口，但由子类决定具体要实例化的类。工厂方法模式将对象的创建过程封装在一个工厂类中，使得客户端可以通过工厂方法来获取所需的对象，而不需要直接依赖于具体类的实例化过程。

## 主要组成部分

**产品接口（Product）**：定义了工厂方法所创建对象的抽象接口。

**具体产品（ConcreteProduct）**：实现产品接口的具体类。

**抽象工厂（Creator）**：声明了工厂方法，通常是一个抽象方法，该方法返回一个产品对象。

**具体工厂（ConcreteCreator）**：实现了工厂方法，负责返回具体的产品实例。

## 优点

**解耦**：客户端不需要知道如何创建具体的产品对象，只需依赖抽象工厂接口。

**扩展性好**：添加新的产品类型时，只需要添加新的具体工厂类，而不需要修改现有的客户端代码。

**代码更具可维护性**：因为对象的创建逻辑被集中在工厂类中，后续的维护和修改变得容易。

## 缺点

**增加系统复杂度**：引入了多个工厂类，导致系统的类结构变得更加复杂。

**客户端需要了解不同的工厂类**：如果工厂方法涉及很多不同的产品，客户端代码可能需要知道哪一个工厂类创建何种产品。

## 示例

**产品接口（`Product`）**：定义了 `operation` 方法，每个具体产品类都实现该方法：

```c++
class Product {
public:
    virtual ~Product() = default;
    virtual void operation() const = 0;
};
```

**具体产品（`ConcreteProductA` 和 `ConcreteProductB`）**：实现了 `Product` 接口的 `operation` 方法，提供了具体的操作：

```c++
// 具体产品A
class ConcreteProductA : public Product {
public:
    void operation() const override {
        std::cout << "Operation of ConcreteProductA" << std::endl;
    }
};

// 具体产品B
class ConcreteProductB : public Product {
public:
    void operation() const override {
        std::cout << "Operation of ConcreteProductB" << std::endl;
    }
};
```

**抽象工厂（`Creator`）**：声明了一个纯虚函数 `factoryMethod`，它返回一个 `Product` 类型的对象。`someOperation` 方法通过工厂方法创建产品并调用其操作方法:

```c++
// 抽象工厂
class Creator {
public:
    virtual ~Creator() = default;
    virtual std::unique_ptr<Product> factoryMethod() const = 0;
    
    void someOperation() const {
        std::unique_ptr<Product> product = factoryMethod();
        product->operation();
    }
};
```

**具体工厂（`ConcreteCreatorA` 和 `ConcreteCreatorB`）**：分别实现了工厂方法，返回不同类型的具体产品（`ConcreteProductA` 或 `ConcreteProductB`）：

```c++
// 具体工厂A
class ConcreteCreatorA : public Creator {
public:
    std::unique_ptr<Product> factoryMethod() const override {
        return std::make_unique<ConcreteProductA>();
    }
};

// 具体工厂B
class ConcreteCreatorB : public Creator {
public:
    std::unique_ptr<Product> factoryMethod() const override {
        return std::make_unique<ConcreteProductB>();
    }
};
```

定义完上述之后再客户端中执行：

```c++
// 客户端代码
int main() {
    ConcreteCreatorA creatorA;
    creatorA.someOperation();  // Output: Operation of ConcreteProductA

    ConcreteCreatorB creatorB;
    creatorB.someOperation();  // Output: Operation of ConcreteProductB

    return 0;
}
```

运行结果如下：

```c++
Operation of ConcreteProductA
Operation of ConcreteProductB
```

通过使用工厂方法模式，我们使得对象的创建过程从客户端代码中分离出来，提高了系统的灵活性和扩展性。

# 11、原型模式

## 概念

原型模式（Prototype Pattern）是一种创建型设计模式，旨在通过复制现有的实例来创建新的对象，而不是通过调用构造函数来实例化新对象。实现原型模式通常需要在对象类中定义一个复制方法（通常是 `clone` 或 `copy` 方法）。

## 组成

**Prototype（原型）接口**：声明一个克隆方法，供具体的原型类实现。

**ConcretePrototype（具体原型）**：实现 `clone` 方法，返回一个当前对象的副本。

**Client（客户端）**：通过原型来创建对象，而不需要知道具体的创建过程。

## 优点

**性能提升**：有些对象的创建过程可能非常复杂和耗时，使用原型模式可以避免重复构造，从而提高性能。

**避免重复代码**：如果有多个相似对象需要创建，直接通过复制已有对象而不是重复编写构造代码可以减少代码冗余。

**灵活性**：可以通过修改原型类的状态，动态改变新克隆对象的内容，而不需要创建新的类。

## 示例

假设我们有一个类 `Shape`，它有一个方法 `clone()` 用来复制对象：

```c++
// 原型接口
class Shape {
public:
    virtual ~Shape() {}
    virtual Shape* clone() const = 0;  // 克隆方法
    virtual void draw() const = 0;     // 打印对象信息
};

// 具体原型类：Circle
class Circle : public Shape {
private:
    int radius;
public:
    Circle(int r) : radius(r) {}
    
    Shape* clone() const override {
        return new Circle(*this);  // 返回当前对象的副本
    }

    void draw() const override {
        cout << "Circle with radius: " << radius << endl;
    }
};

// 具体原型类：Rectangle
class Rectangle : public Shape {
private:
    int width, height;
public:
    Rectangle(int w, int h) : width(w), height(h) {}
    
    Shape* clone() const override {
        return new Rectangle(*this);  // 返回当前对象的副本
    }

    void draw() const override {
        cout << "Rectangle with width: " << width << " and height: " << height << endl;
    }
};

// 客户端代码
int main() {
    // 创建一个圆形对象
    Circle* c1 = new Circle(10);
    // 克隆出一个新圆形对象
    Circle* c2 = static_cast<Circle*>(c1->clone());

    // 创建一个矩形对象
    Rectangle* r1 = new Rectangle(5, 7);
    // 克隆出一个新矩形对象
    Rectangle* r2 = static_cast<Rectangle*>(r1->clone());

    // 绘制对象
    c1->draw();
    c2->draw();
    r1->draw();
    r2->draw();

    // 释放内存
    delete c1;
    delete c2;
    delete r1;
    delete r2;

    return 0;
}
```

# 12、模板方法模式

## 概念

模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的框架，在框架中将一些步骤延迟到子类中实现。模板方法使得可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

## 核心思想

**定义一个模板方法**：模板方法是算法的骨架，它将某些步骤的实现留给子类。具体的步骤由抽象方法或者钩子方法来表示。

**具体子类提供实现**：子类可以实现模板方法中的抽象步骤，也可以通过钩子方法控制步骤的执行。

## 组成

**抽象类**：定义了模板方法，包含算法的骨架，并声明一些步骤为抽象方法（让子类实现）或者钩子方法（可选实现，子类可以选择重写）。

**具体子类**：实现模板方法中定义的抽象步骤。

## 优点

**代码复用**：模板方法模式允许子类共享一个公共的算法骨架，减少重复代码。

**扩展性**：子类可以通过重写抽象方法来扩展算法的某些步骤，但不会改变算法的整体结构。

## 缺点

**灵活性受限**：算法的结构固定，子类只能修改部分步骤，不能改变整个算法的流程。

**子类重写多**：如果子类需要重写多个步骤，可能会导致代码重复，并且增加维护成本。

## 拓展：什么是钩子方法

钩子方法是模板方法模式中的一个概念，它允许在算法的执行过程中，子类有机会**插入自己的行为**，但不强制要求子类必须实现这些方法。钩子方法通常有默认的实现，子类可以选择重写（覆盖）它们，也可以使用默认实现。

## 示例

定义抽象类AbstractClass，它定义了一个模板方法 `templateMethod`，该方法包含了算法的骨架。`step1` 是一个已实现的方法，`step2` 是一个纯虚函数，`step3` 是一个可以被子类重写的钩子方法：

```c++
// 抽象类
class AbstractClass {
public:
    // 模板方法：定义算法的骨架
    void templateMethod() {
        step1();
        step2();
        step3();
    }

protected:
    // 第一步：具体实现
    void step1() {
        std::cout << "Step 1: Common implementation." << std::endl;
    }

    // 第二步：抽象方法，具体子类必须实现
    virtual void step2() = 0;

    // 第三步：钩子方法，子类可以选择性重写
    virtual void step3() {
        std::cout << "Step 3: Default implementation." << std::endl;
    }
};
```

**`ConcreteClassA`** 和 **`ConcreteClassB`**这两个子类分别实现了 `step2` 和 `step3` 方法，`ConcreteClassB` 使用了父类的默认实现（即 `step3`）:

```c++
// 具体子类1
class ConcreteClassA : public AbstractClass {
protected:
    void step2() override {
        std::cout << "ConcreteClassA step 2: Custom implementation." << std::endl;
    }

    void step3() override {
        std::cout << "ConcreteClassA step 3: Custom implementation." << std::endl;
    }
};

// 具体子类2
class ConcreteClassB : public AbstractClass {
protected:
    void step2() override {
        std::cout << "ConcreteClassB step 2: Custom implementation." << std::endl;
    }
    
    // ConcreteClassB使用默认的step3实现
};
```

在客户端中执行：

```c++
int main() {
    ConcreteClassA objA;
    ConcreteClassB objB;
    
    std::cout << "Executing template method for ConcreteClassA:" << std::endl;
    objA.templateMethod();  // 调用模板方法
    
    std::cout << "\nExecuting template method for ConcreteClassB:" << std::endl;
    objB.templateMethod();  // 调用模板方法

    return 0;
}
```

最终的输出为：

```
Executing template method for ConcreteClassA:
Step 1: Common implementation.
ConcreteClassA step 2: Custom implementation.
ConcreteClassA step 3: Custom implementation.

Executing template method for ConcreteClassB:
Step 1: Common implementation.
ConcreteClassB step 2: Custom implementation.
Step 3: Default implementation.
```

# 13、迪米特法则

## 概念

**迪米特法则**（Law of Demeter, LoD），也称为**最少知识原则**，是一种软件设计原则，旨在减少模块之间的耦合度。该法则的核心思想是：一个对象应该对其他对象有尽可能少的了解，只与直接的朋友（直接依赖的对象）进行交互，而不是与陌生对象或其内部结构进行交互。

## 主要原则

**只与直接朋友交互**：一个对象只应该与它直接的成员对象、参数对象或返回对象进行交互。

**避免链式调用**：尽量避免通过多个对象的链式调用来访问数据。这意味着如果你有 `A` 对象的引用，应该避免通过 `A` 对象去访问 `B`，然后再通过 `B` 访问 `C`。

## 优点

**降低耦合度**：通过减少对象之间的相互依赖，使得代码更易于维护和扩展。

**提高可读性**：代码更清晰，易于理解各个对象之间的关系。

**增强模块化**：使得代码的各个部分更独立，便于单元测试。

## 示例

假设我们有以下类：

```c++
class Engine {
public:
    int getHorsePower() { return 300; }
};

class Car {
private:
    Engine engine;
public:
    Engine getEngine() { return engine; }
};

class Driver {
public:
    void drive(Car car) {
        // 不符合迪米特法则的做法
        int hp = car.getEngine().getHorsePower(); // 链式调用
    }
};
```

在这个例子中，`Driver` 类通过 `Car` 类访问了 `Engine` 类的细节。这种做法违反了迪米特法则。

#### 符合迪米特法则的做法

```c++
class Engine {
public:
    int getHorsePower() { return 300; }
};

class Car {
private:
    Engine engine;
public:
    int getHorsePower() {
        return engine.getHorsePower(); // Car 直接与 Engine 交互
    }
};

class Driver {
public:
    void drive(Car car) {
        int hp = car.getHorsePower(); // 不再进行了链式调用
    }
};
```

在这个版本中，`Driver` 类只关心 `Car` 类的接口，不需要了解 `Car` 内部实现的细节。

# 14、外观模式

## 概念

**外观模式**（Facade Pattern）是一种结构性设计模式，旨在为复杂的子系统提供一个简化的接口。通过外观模式，客户端可以通过一个统一的接口与多个子系统进行交互，而不需要直接与它们的复杂实现细节打交道。

## 主要特征

**简化接口**：外观模式创建一个简单的接口，隐藏了系统的复杂性，使得系统更易于使用。

**减少依赖**：客户端与子系统之间的依赖关系减少，使得系统更具灵活性和可维护性。

**解耦合**：客户端不需要了解子系统的内部实现，只需与外观类交互。

## 优点

**简化使用**：客户端通过简单的接口与复杂的子系统交互，减少了调用复杂性。

**提高可维护性**：子系统的实现可以独立于客户端进行更改，只要外观接口不变，客户端代码就不需要修改。

**提高灵活性**：可以轻松地替换或添加子系统而不影响客户端。

## 示例

假设我们有一个复杂的音响系统，包括多个组件：音频播放器、放大器和扬声器。客户端在使用这些组件时，可能会面临复杂的接口和调用过程。

复杂子系统的定义为：

```c++
class AudioPlayer {
public:
    void play() { std::cout << "Playing audio." << std::endl; }
};

class Amplifier {
public:
    void turnOn() { std::cout << "Amplifier turned on." << std::endl; }
};

class Speaker {
public:
    void setVolume(int level) { 
        std::cout << "Setting volume to " << level << "." << std::endl; 
    }
};
```

外观类为：

```c++
class AudioSystemFacade {
private:
    AudioPlayer player;
    Amplifier amp;
    Speaker speaker;

public:
    void playMusic(int volume) {
        amp.turnOn();
        speaker.setVolume(volume);
        player.play();
    }
};
```

客户端代码为：

```c++
int main() {
    AudioSystemFacade audioSystem;
    audioSystem.playMusic(10); // 客户端通过外观类来播放音乐
    return 0;
}
```

只需要通过外观类来进行播放音乐即可，不用再分别调用扬声器、放大器等类。

# 15、建造者模式

## 概念

**建造者模式**（Builder Pattern）是一种创建型设计模式，旨在通过使用多个简单对象一步一步构建一个复杂对象。该模式允许用户通过一个统一的接口来构建不同类型和表示的对象，避免了构造器参数过多或复杂的情况。

## 主要特征

**分离构建和表示**：建造者模式将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。

**简化对象创建**：通过使用建造者，客户端可以以更清晰的方式来创建复杂对象，避免了直接使用构造函数的混乱。

**灵活性**：可以在不改变对象的内部表示的情况下，改变其构建过程。

## 示例

假设我们要构建一个复杂的 `Computer` 对象，它有多个可选组件：CPU、内存、硬盘等。

**首先创建一个产品类Computer：**

```c++
class Computer {
public:
    std::string cpu;
    std::string ram;
    std::string storage;

    void showSpecifications() {
        std::cout << "CPU: " << cpu << ", RAM: " << ram << ", Storage: " << storage << std::endl;
    }
};
```

**然后定义建造者接口**：建造者接口声明了创建复杂对象所需的各种构建步骤。

```c++
class ComputerBuilder {
public:
    virtual void buildCPU() = 0;
    virtual void buildRAM() = 0;
    virtual void buildStorage() = 0;
    virtual Computer* getComputer() = 0;
};
```

**定义具体的建造者**：具体建造者实现了建造者接口中定义的构建步骤，负责具体的对象构建逻辑。

```c++
class GamingComputerBuilder : public ComputerBuilder {
private:
    Computer* computer;

public:
    GamingComputerBuilder() {
        computer = new Computer();
    }

    void buildCPU() override {
        computer->cpu = "High-end CPU";
    }

    void buildRAM() override {
        computer->ram = "16GB";
    }

    void buildStorage() override {
        computer->storage = "1TB SSD";
    }

    Computer* getComputer() override {
        return computer;
    }
};
```

**定义指导者**：指导者负责定义构建复杂对象的顺序和过程。它调用具体建造者的方法来完成构建。

```c++
class ComputerDirector {
private:
    ComputerBuilder* builder;

public:
    ComputerDirector(ComputerBuilder* b) : builder(b) {}

    Computer* constructComputer() {
        builder->buildCPU();
        builder->buildRAM();
        builder->buildStorage();
        return builder->getComputer();
    }
};
```

**定义客户端代码：**

```c++
int main() {
    GamingComputerBuilder* game_builder = new GamingComputerBuilder();
    ComputerDirector director(game_builder); //告诉指导者要构建的对象是传入的类的对象

    Computer* gamingPC = director.constructComputer();
    gamingPC->showSpecifications();

    delete gamingPC;
    delete builder;

    return 0;
}
```

这种模式的结构使得你可以非常灵活地创建不同配置的复杂对象，同时保持代码的可读性和可维护性。

# 16、观察者模式

## 概念

观察者模式（Observer Pattern）是一种行为设计模式，用于定义对象之间的一对多依赖关系。当一个对象的状态发生变化时，它的所有依赖对象（观察者）都会自动收到通知并更新。这种模式通常用于实现事件驱动的系统。

## 主要组成

**主题（Subject）**：主题是被观察的对象，维护一组观察者，并提供添加、删除观察者的方法。

**观察者（Observer）**：观察者是依赖于主题的对象，当主题的状态发生变化时，观察者会收到通知并进行相应的更新。

## 工作流程

1️⃣观察者注册到主题。

2️⃣当主题的状态发生变化时，它会通知所有注册的观察者。

3️⃣观察者接收到通知后，自行更新其状态。

## 优点

**解耦**：主题和观察者之间的耦合度低，观察者可以独立于主题进行变化。

**动态订阅**：可以在运行时自由地添加或移除观察者。

**提高灵活性**：允许多种观察者响应同一主题的变化。

## 示例

**定义抽象的观察者类和抽象的主题类**：

```c++
// 抽象观察者类：定义了一个 update 方法，所有观察者都需实现此方法以响应主题的通知。
class Observer {
public:
    virtual ~Observer() {}
    virtual void update(const std::string& message) = 0;
};

// 抽象主题类：护一个观察者列表，并提供 attach、detach 和 notify 方法。
class Subject {
public:
    virtual ~Subject() {}
    virtual void attach(Observer* observer) {
        observers.push_back(observer);
    }
    virtual void detach(Observer* observer) {
        observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
    }
    virtual void notify(const std::string& message) {
        for (Observer* observer : observers) {
            observer->update(message);
        }
    }

private:
    std::vector<Observer*> observers;
};
```

**定义具体主题类和具体的观察者类：**

```c++
// 具体主题类：继承自 Subject，实现了状态变化的方法 changeState，并在状态变化时通知所有观察者。
class ConcreteSubject : public Subject {
public:
    void changeState(const std::string& newState) {
        state = newState;
        notify("State changed to: " + state);
    }

private:
    std::string state;
};

// 具体观察者类：继承自 Observer，实现了 update 方法，以输出接收到的通知。
class ConcreteObserver : public Observer {
public:
    ConcreteObserver(const std::string& name) : name(name) {}
    
    void update(const std::string& message) override {
        std::cout << name << " received update: " << message << std::endl;
    }

private:
    std::string name;
};
```

**在客户端中运行：**

```c++
// 使用示例
int main() {
    ConcreteSubject subject;

    ConcreteObserver observer1("Observer 1");
    ConcreteObserver observer2("Observer 2");

    subject.attach(&observer1);
    subject.attach(&observer2);

    subject.changeState("New State 1");
    subject.changeState("New State 2");

    // 解除观察者的注册
    subject.detach(&observer1);
    subject.changeState("New State 3");

    return 0;
}
```

程序的输出为：

```
Observer 1 received update: State changed to: New State 1
Observer 2 received update: State changed to: New State 1
Observer 1 received update: State changed to: New State 2
Observer 2 received update: State changed to: New State 2
Observer 2 received update: State changed to: New State 3
```

# 17、抽象工厂模式

## 概念

抽象工厂模式是一种创建型设计模式，旨在提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。这个模式通常用于需要创建多个相关对象的场景，并且这些对象可能属于不同的类别。

**工厂**：在抽象工厂模式中，工厂负责创建对象。抽象工厂定义了创建一组产品的接口，而具体工厂实现这些接口以创建具体的产品。

**产品族**：抽象工厂模式可以创建多个相关的产品，每个产品属于同一族。每个具体工厂通常实现一种产品族的创建。

## 主要构成

**抽象工厂**：声明创建产品的方法。

**具体工厂**：实现抽象工厂的接口，负责实例化具体产品。

**抽象产品**：定义产品的接口。

**具体产品**：实现抽象产品的接口，代表具体的产品实现。

## 优点

**解耦**：客户端代码只依赖于抽象工厂和抽象产品，不依赖于具体产品的实现。这降低了代码之间的耦合度。

**易于扩展**：如果需要添加新的产品，只需创建新的具体工厂和产品，而不需要修改已有的代码。

**一致性**：可以确保同一产品族中的对象能协同工作，避免了不兼容的对象组合。

## 示例

我们需要创建一个跨平台的 GUI 应用程序，该应用程序能够在 Windows 和 macOS 上运行。

1️⃣首先定义抽象产品类：`Button` 和 `TextBox` 是抽象产品，它们定义了需要实现的接口。

```c++
// 抽象产品：按钮
class Button {
public:
    virtual void paint() = 0; // 绘制按钮
};

// 抽象产品：文本框
class TextBox {
public:
    virtual void render() = 0; // 渲染文本框
};
```

2️⃣定义具体产品类：`WindowsButton`、`WindowsTextBox`、`MacOSButton` 和 `MacOSTextBox` 是具体产品的实现，它们实现了抽象产品的接口。

```c++
// 具体产品：Windows 按钮
class WindowsButton : public Button {
public:
    void paint() override {
        std::cout << "Rendering Windows Button." << std::endl;
    }
};

// 具体产品：Windows 文本框
class WindowsTextBox : public TextBox {
public:
    void render() override {
        std::cout << "Rendering Windows TextBox." << std::endl;
    }
};

// 具体产品：macOS 按钮
class MacOSButton : public Button {
public:
    void paint() override {
        std::cout << "Rendering MacOS Button." << std::endl;
    }
};

// 具体产品：macOS 文本框
class MacOSTextBox : public TextBox {
public:
    void render() override {
        std::cout << "Rendering MacOS TextBox." << std::endl;
    }
};
```

3️⃣定义抽象工厂类：`GUIFactory` 是抽象工厂，定义了创建产品的方法。

```c++
// 抽象工厂
class GUIFactory {
public:
    virtual Button* createButton() = 0; // 创建按钮
    virtual TextBox* createTextBox() = 0; // 创建文本框
};
```

4️⃣定义具体工厂类：`WindowsFactory` 和 `MacOSFactory` 实现了抽象工厂，负责创建具体的产品。

```c++
// 具体工厂：Windows 工厂
class WindowsFactory : public GUIFactory {
public:
    Button* createButton() override {
        return new WindowsButton();
    }
    
    TextBox* createTextBox() override {
        return new WindowsTextBox();
    }
};

// 具体工厂：macOS 工厂
class MacOSFactory : public GUIFactory {
public:
    Button* createButton() override {
        return new MacOSButton();
    }
    
    TextBox* createTextBox() override {
        return new MacOSTextBox();
    }
};
```

5️⃣定义完之后在客户端实现：客户端根据操作系统选择具体工厂，并使用工厂创建按钮和文本框，最后调用它们的方法。

```c++
int main() {
    GUIFactory* factory;

    // 假设我们根据操作系统选择工厂
    std::string os = "Windows"; // 或者 "MacOS"

    if (os == "Windows") {
        factory = new WindowsFactory();
    } else {
        factory = new MacOSFactory();
    }

    // 使用工厂创建组件
    Button* button = factory->createButton();
    TextBox* textBox = factory->createTextBox();

    // 使用创建的组件
    button->paint();
    textBox->render();

    // 清理资源
    delete button;
    delete textBox;
    delete factory;

    return 0;
}
```

## 反射

### 概念

**反射**是程序在运行时能够查看和修改自身结构的能力。它允许程序动态地获取对象的类型信息、方法、属性等，并可以在运行时创建对象、调用方法或访问属性。

## 反射与抽象工厂模式的结合

结合反射与抽象工厂模式，可以实现更灵活的对象创建机制。例如，可以根据配置文件或输入字符串动态地创建不同的产品，而不需要在代码中显式地指定具体的工厂类。

## 示例

创建抽象产品和具体产品类：

```c++
// 抽象产品
class Button {
public:
    virtual void paint() = 0;
};

// 具体产品
class WindowsButton : public Button {
public:
    void paint() override {
        std::cout << "Rendering Windows Button." << std::endl;
    }
};

class MacOSButton : public Button {
public:
    void paint() override {
        std::cout << "Rendering MacOS Button." << std::endl;
    }
};
```

创建抽象工厂类：

```c++
class GUIFactory {
public:
    virtual std::unique_ptr<Button> createButton() = 0;
};
```

创建具体工厂类：

```c++
class WindowsFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WindowsButton>();
    }
};

class MacOSFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacOSButton>();
    }
};
```

创建工厂映射类：(C++中是模拟反射)使用字符串参数根据输入返回相应的工厂实例，模拟了反射的行为。

```c++
class FactoryProvider {
public:
    static std::unique_ptr<GUIFactory> getFactory(const std::string& type) {
        if (type == "Windows") {
            return std::make_unique<WindowsFactory>();
        } else if (type == "MacOS") {
            return std::make_unique<MacOSFactory>();
        }
        return nullptr;
    }
};
```

然后在客户端执行：

```c++
int main() {
    std::string os = "Windows"; // 假设从配置中读取

    // 使用工厂提供者获取工厂
    auto factory = FactoryProvider::getFactory(os);
    if (factory) {
        auto button = factory->createButton();
        button->paint();
    } else {
        std::cout << "Unknown OS type." << std::endl;
    }

    return 0;
}
```

# 18、状态模式

## 概念

状态模式是一种行为设计模式，它允许对象在内部状态改变时改变其行为。这意味着对象的行为会随着其状态的不同而有所不同，状态的变化使得对象看起来像是其类发生了变化。

## 主要组成

**上下文（Context）**：维护一个对状态对象的引用。

**状态接口（State）**：定义状态的接口，声明与上下文相关的行为。

**具体状态类（Concrete State）**：实现状态接口，封装与具体状态相关的行为。

## 优点

**清晰的结构**：状态的变化和相关行为的实现被分离，代码更加清晰。

**易于扩展**：可以轻松添加新的状态，只需创建新的具体状态类，而无需修改现有代码。

## 示例

模拟一个文档的状态管理，文档可以处于 "草稿"、"审核" 和 "发布" 三种状态。

首先前向声明状态类：

```c++
// 前向声明状态类
class DocumentState;
```

然后定义上下文类：维护一个指向当前状态对象的指针，初始化为草稿状态。

```c++
// 上下文类
class Document {
public:
    Document() : state(std::make_shared<DraftState>()) {}

    void setState(std::shared_ptr<DocumentState> newState) {
        state = newState;
    }

    void publish();

private:
    std::shared_ptr<DocumentState> state;
};
```

然后定义状态接口类：定义了 `publish` 方法，具体状态类实现此方法。

```c++
// 状态接口
class DocumentState {
public:
    virtual ~DocumentState() = default;
    virtual std::shared_ptr<DocumentState> publish(Document& document) = 0;
};
```

定义三个具体状态类：

```c++
// 草稿状态：此时可以发布(publish)，发布完之后状态变为已发布状态
class DraftState : public DocumentState {
public:
    std::shared_ptr<DocumentState> publish(Document& document) override {
        std::cout << "Document published!" << std::endl;
        return std::make_shared<PublishedState>();
    }
};

// 审核状态：此时不可以发布，状态还是审核状态
class ReviewState : public DocumentState {
public:
    std::shared_ptr<DocumentState> publish(Document& document) override {
        std::cout << "Document is under review, can't publish yet." << std::endl;
        return std::make_shared<ReviewState>();
    }
};

// 发布状态：此时也不可以发布，状态还是已发布状态
class PublishedState : public DocumentState {
public:
    std::shared_ptr<DocumentState> publish(Document& document) override {
        std::cout << "Document is already published." << std::endl;
        return std::make_shared<PublishedState>();
    }
};
```

在客户端中执行：

```c++
// 使用示例
int main() {
    Document doc;
    doc.publish();  // 输出: Document published!
    doc.publish();  // 输出: Document is already published.

    return 0;
}
```

# 19、适配器模式

## 概念

适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一种接口。适配器模式使得原本由于接口不兼容而无法一起工作的类可以协同工作。

## 特点

**解耦**：适配器模式通过创建一个适配器类来解耦客户端与被适配类之间的关系。

**接口转换**：适配器负责将客户端请求转换成被适配类可以理解的格式。

**灵活性**：可以在不修改现有代码的情况下，将新类或旧类集成到系统中。

## 组成部分

**目标接口（Target Interface）**：客户端所期望的接口。

**源类（Adaptee）**：需要适配的类，通常是现有的类。

**适配器（Adapter）**：实现目标接口，并通过引用源类的实例来调用源类的方法。

## 优点

**提高了类的复用性**：通过适配器，可以在新系统中使用老旧的类。

**更好的系统灵活性**：可以在不修改现有代码的情况下，轻松地添加新的适配器以支持不同的类。

**符合开闭原则**：系统对扩展开放，对修改封闭。

## 示例

假设我们有一个旧的 `OldPrinter` 类，它只支持打印字符串，而我们需要将其适配为一个新的 `Printer` 接口。

首先定义一个目标接口类：定义了客户端所期望的 `print` 方法。

```c++
// 目标接口
class Printer {
public:
    virtual void print(const std::string &text) = 0;
};
```

定义源类：实现了旧的打印逻辑，提供 `printText` 方法。

```c++
// 源类
class OldPrinter {
public:
    void printText(const std::string &text) {
        std::cout << "Old Printer: " << text << std::endl;
    }
};
```

定义适配器类：实现了目标接口，并在其 `print` 方法中调用 `OldPrinter` 的 `printText` 方法，从而完成适配。

```c++
// 适配器类
class PrinterAdapter : public Printer {
public:
    PrinterAdapter(OldPrinter *oldPrinter) : oldPrinter(oldPrinter) {}

    void print(const std::string &text) override {
        oldPrinter->printText(text); // 调用源类的方法
    }

private:
    OldPrinter *oldPrinter; // 持有源类的引用
};
```

定义完之后在客户端内进行验证：

```c++
// 客户端代码
int main() {
    OldPrinter oldPrinter;
    Printer *printer = new PrinterAdapter(&oldPrinter);

    printer->print("Hello, World!"); // 输出: Old Printer: Hello, World!

    delete printer;
    return 0;
}
```

# 20、备忘录模式

## 概念

备忘录模式（Memento Pattern）是一种行为设计模式，用于在不暴露对象内部状态的情况下，捕获和保存一个对象的状态，以便在需要时能够恢复到该状态。这个模式主要用于实现“撤销”操作，允许用户在不修改对象的情况下访问和恢复过去的状态。

## 主要组成

**备忘录（Memento）**：用于存储对象的内部状态。它通常是一个不可变的对象，负责保存需要恢复的状态。

**发起人（Originator）**：负责创建备忘录对象并使用备忘录恢复状态。发起人包含需要保存和恢复的状态。

**管理者（Caretaker）**：管理备忘录的生命周期，负责保存和恢复备忘录。管理者不改变备忘录的内容，只负责存储和获取。

## 优点

**封装性**：备忘录模式提供了一种保护对象状态的方式，不需要暴露内部细节。

**简单性**：实现相对简单，易于理解和使用。

## 缺点

**内存占用**：频繁创建备忘录可能会导致内存消耗增加。

**管理复杂性**：需要额外的管理者类来处理备忘录的存储和恢复。

## 示例

使用备忘录模式保存和恢复文本编辑器中的文本状态。

首先创建备忘录类：负责存储发起人的状态。它只提供了获取状态的方法，确保发起人的内部状态不被外部修改。

```c++
// 备忘录类
class Memento {
public:
    Memento(const std::string& state) : state(state) {}
    std::string getState() const { return state; }

private:
    std::string state; // 保存的状态
};
```

然后创建发起人的类：负责创建和恢复备忘录。它包含一个状态，并且可以通过 `saveStateToMemento` 方法创建备忘录，通过 `getStateFromMemento` 方法恢复状态。

```c++
//发起人
class Originator {
public:
    void setState(const std::string& state) {
        this->state = state;
        std::cout << "State set to: " << state << std::endl;
    }

    std::shared_ptr<Memento> saveStateToMemento() {
        return std::make_shared<Memento>(state); // 创建备忘录
    }

    void getStateFromMemento(std::shared_ptr<Memento> memento) {
        state = memento->getState(); // 恢复状态
        std::cout << "State restored to: " << state << std::endl;
    }

private:
    std::string state; // 发起人的状态
};
```

创建管理者类：存储多个备忘录，并提供添加和获取备忘录的方法，但不处理备忘录的内容。

```c++
// 管理者类
class Caretaker {
public:
    void addMemento(std::shared_ptr<Memento> memento) {
        mementos.push_back(memento); // 保存备忘录
    }

    std::shared_ptr<Memento> getMemento(int index) {
        return mementos[index]; // 获取备忘录
    }

private:
    std::vector<std::shared_ptr<Memento>> mementos; // 备忘录列表
};
```

在客户端中执行：

```c++
int main() {
    Originator originator;
    Caretaker caretaker;

    originator.setState("State #1");
    caretaker.addMemento(originator.saveStateToMemento());

    originator.setState("State #2");
    caretaker.addMemento(originator.saveStateToMemento());

    originator.setState("State #3");
    std::cout << "Restoring to previous state..." << std::endl;

    originator.getStateFromMemento(caretaker.getMemento(1)); // 恢复到 State #2

    return 0;
}
```

备忘录模式非常适合需要保存和恢复对象状态的场景，能够有效地解决状态管理的问题。

# 21、组合模式

## 概念

组合模式（Composite Pattern）是一种结构型设计模式，用于将对象组合成树形结构，以表示“部分-整体”的层次关系。组合模式允许客户以统一的方式对待单个对象和对象组合，简化了客户端代码的使用。

## 主要组成	

**组件接口（Component）**：定义了叶子节点和组合节点的共同接口，声明了可以执行的操作。

**叶子节点（Leaf）**：实现组件接口，代表组合中的基本元素，叶子节点没有子节点。

**组合节点（Composite）**：也实现组件接口，代表可以包含其他子组件（叶子或组合节点）的节点。组合节点可以管理其子节点并实现相关操作。

## 优点

**简化客户端代码**：客户端可以一致地使用叶子节点和组合节点，减少了代码的复杂性。

**灵活性**：可以在运行时动态地添加和删除组合元素，易于扩展。

## 缺点

**设计复杂性**：组合模式可能导致设计过于复杂，尤其是在需要处理大量组件时。

**性能问题**：如果组件层次结构过于深，可能会影响性能。

## 示例

用组织模式来实现公司的组织结构。

首先定义组件接口类：定义了 `showDetails` 方法，所有员工类型（普通员工和管理者）都需要实现这个方法。

```c++
// 组件接口
class Employee {
public:
    virtual ~Employee() {}
    virtual void showDetails() const = 0;
};
```

定义普通员工类：实现了 `Employee` 接口，表示公司中的具体员工，比如 Alice 和 Bob。

```c++
// 普通员工
class Staff : public Employee {
public:
    Staff(const std::string& name) : name(name) {}

    void showDetails() const override {
        std::cout << "Staff: " << name << std::endl;
    }

private:
    std::string name;
};
```

定义管理者类：也实现了 `Employee` 接口，代表管理者，可以管理多个员工；通过 `add` 方法将下属员工（包括其他管理者）添加到自己的管理列表中。

```c++
// 管理者
class Manager : public Employee {
public:
    Manager(const std::string& name) : name(name) {}

    void add(std::shared_ptr<Employee> employee) {
        employees.push_back(employee);
    }

    void showDetails() const override {
        std::cout << "Manager: " << name << std::endl;
        for (const auto& employee : employees) {
            employee->showDetails(); // 递归调用，显示下属
        }
    }

private:
    std::string name;
    std::vector<std::shared_ptr<Employee>> employees; // 存储下属
};
```

在客户端中执行：

```c++
// 使用示例
int main() {
    // 创建普通员工
    auto staff1 = std::make_shared<Staff>("Alice");
    auto staff2 = std::make_shared<Staff>("Bob");

    // 创建管理者
    auto manager1 = std::make_shared<Manager>("Charlie");
    manager1->add(staff1); // Charlie 管理 Alice
    manager1->add(staff2); // Charlie 管理 Bob

    // 创建另一个普通员工
    auto staff3 = std::make_shared<Staff>("Dave");

    // 创建另一个管理者
    auto manager2 = std::make_shared<Manager>("Eve");
    manager2->add(staff3); // Eve 管理 Dave
    manager2->add(manager1); // Eve 管理 Charlie

    // 打印组织结构
    std::cout << "Organization Structure:" << std::endl;
    manager2->showDetails(); // 显示整个组织结构

    return 0;
}
```

当我们调用 `manager2->showDetails()` 时，程序会递归地打印出整个组织结构：

```
Organization Structure:
Manager: Eve
Staff: Dave
Manager: Charlie
Staff: Alice
Staff: Bob
```

无论是普通员工还是管理者，都通过 `Employee` 接口来处理，使得代码更加灵活和易于维护。

# 22、迭代器模式

## 概念

迭代器模式是一种设计模式，它允许顺序访问集合对象中的元素，而不暴露该对象的内部表示。迭代器模式通常用于容器类（如列表、集合、数组等），使得用户可以通过统一的接口遍历这些集合。

## 组成

**迭代器接口**：定义访问和遍历元素的标准方法。

**具体迭代器**：实现迭代器接口，维护对集合的引用，提供具体的遍历逻辑。

**聚合接口**：包含集合的实现，提供创建迭代器的方法。

**具体聚合**：实现了聚合接口，返回一个具体的迭代器。

## 示例

下面演示使用迭代器模式遍历一个简单的集合：

定义一个迭代器接口：定义了基本的迭代器操作，包括重置、移动到下一个元素、检查是否完成和获取当前元素。

```c++
// 迭代器接口
class Iterator {
public:
    virtual ~Iterator() {}
    virtual void First() = 0; // 重置到第一个元素
    virtual void Next() = 0;  // 移动到下一个元素
    virtual bool IsDone() const = 0; // 检查是否完成
    virtual int CurrentItem() const = 0; // 获取当前元素
};
```

定义具体迭代器类：实现了迭代器接口，维护当前索引并提供对集合的访问。

```c++
// 具体迭代器
class ConcreteIterator : public Iterator {
public:
    ConcreteIterator(const std::vector<int>& collection) 
        : collection(collection), current(0) {}

    void First() override {
        current = 0;
    }

    void Next() override {
        if (current < collection.size()) {
            ++current;
        }
    }

    bool IsDone() const override {
        return current >= collection.size();
    }

    int CurrentItem() const override {
        return collection[current];
    }

private:
    const std::vector<int>& collection; // 被迭代的集合
    size_t current; // 当前索引
};
```

定义聚合接口类：定义了创建迭代器的方法

```c++
// 聚合接口
class Aggregate {
public:
    virtual ~Aggregate() {}
    virtual std::unique_ptr<Iterator> CreateIterator() = 0; // 创建迭代器
};
```

定义具体聚合类：实现了聚合接口，提供添加元素的功能，并能够创建具体的迭代器。

```c++
// 具体聚合
class ConcreteAggregate : public Aggregate {
public:
    void Add(int value) {
        items.push_back(value);
    }

    std::unique_ptr<Iterator> CreateIterator() override {
        return std::make_unique<ConcreteIterator>(items);
    }

private:
    std::vector<int> items; // 存储的元素
};
```

定义完之后在客户端中实现：

```c++
int main() {
    ConcreteAggregate aggregate;
    aggregate.Add(1);
    aggregate.Add(2);
    aggregate.Add(3);
    aggregate.Add(4);
    aggregate.Add(5);

    // 创建迭代器
    auto iterator = aggregate.CreateIterator();

    // 使用迭代器遍历集合
    for (iterator->First(); !iterator->IsDone(); iterator->Next()) {
        std::cout << iterator->CurrentItem() << " "; // 输出: 1 2 3 4 5
    }
    std::cout << std::endl;

    return 0;
}
```

# 23、单例模式

## 概念

单例模式（Singleton Pattern）是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。单例模式常用于需要控制资源访问的情况，比如数据库连接、日志管理器等。

## 特点

**唯一性**：确保类只有一个实例。

**全局访问**：提供一个静态方法来获取该实例。

**懒加载**：实例在第一次使用时创建，而不是在程序启动时创建。

## 示例

在许多应用程序中，通常只需要一个数据库连接管理器来管理与数据库的连接。使用单例模式可以确保只有一个连接管理器实例，以避免创建多个连接，从而节省资源。

```c++
class DatabaseConnectionManager {
public:
    // 禁止拷贝构造和赋值操作
    DatabaseConnectionManager(const DatabaseConnectionManager&) = delete;
    DatabaseConnectionManager& operator=(const DatabaseConnectionManager&) = delete;

    // 获取单例实例：此方法是获得本类实例的唯一全局访问点
    static DatabaseConnectionManager& getInstance() {
        static DatabaseConnectionManager instance; // 局部静态变量
        return instance;
    }

    // 示例方法：模拟连接数据库
    void connect() {
        std::cout << "Connected to the database." << std::endl;
    }

    // 示例方法：模拟关闭数据库连接
    void disconnect() {
        std::cout << "Disconnected from the database." << std::endl;
    }

private:
    // 私有构造函数
    DatabaseConnectionManager() {
        std::cout << "DatabaseConnectionManager instance created." << std::endl;
    }
};

int main() {
    // 获取数据库连接管理器的实例
    DatabaseConnectionManager& dbManager = DatabaseConnectionManager::getInstance();

    // 使用数据库连接管理器
    dbManager.connect();
    dbManager.disconnect();

    return 0;
}
```

# 24、合成/聚合复用原则

## 概念

合成/聚合复用原则（Composition/Aggregation Reuse Principle，CARP）是一种设计原则，用于指导软件系统中的类和对象之间的关系。它强调使用组合（Composition）和聚合（Aggregation）来实现代码的重用，而不是通过继承。

## 组成

**合成（Composition）**：表示“拥有”的关系，指一个类作为另一类的组成部分。合成的生命周期是紧密耦合的，即如果包含类被销毁，组成部分也会被销毁。

**聚合（Aggregation）**：表示“使用”的关系，指一个类可以使用另一个类，但它们之间的生命周期相对独立。即使包含类被销毁，组成部分也可以独立存在。

## 优点

**灵活性**：通过组合和聚合，可以在运行时动态地改变对象的行为。

**降低耦合度**：相较于继承，组合和聚合减少了子类与父类之间的紧密耦合，使得系统更易于维护和扩展。

**提高复用性**：通过组合对象，可以在不同的上下文中复用同一组件，而不需要通过继承创建多个子类。

## 示例

假设我们在开发一个图形界面系统，我们可以使用合成和聚合的原则来组织不同的图形元素。

创建基础图形类：定义了一个纯虚函数 `draw()`，所有具体图形类都需要实现这个方法。

```c++
// 基础图形类
class Shape {
public:
    virtual void draw() = 0; // 纯虚函数
    virtual ~Shape() = default;
};
```

创建具体图形类：`Circle` 和 `Rectangle` 是 `Shape` 的具体实现，分别实现了 `draw()` 方法。

```c++
// 具体图形类：圆形
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Circle" << std::endl;
    }
};

// 具体图形类：矩形
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Rectangle" << std::endl;
    }
};
```

创建组合类：`Canvas` 类聚合了多个 `Shape` 对象，通过 `addShape()` 方法添加图形，并通过 `drawShapes()` 方法绘制所有图形。

```c++
// 组合类：画板
class Canvas {
public:
    void addShape(std::shared_ptr<Shape> shape) {
        shapes.push_back(shape);
    }

    void drawShapes() {
        for (const auto& shape : shapes) {
            shape->draw(); // 调用每个图形的绘制方法
        }
    }

private:
    std::vector<std::shared_ptr<Shape>> shapes; // 聚合多个图形对象
};

```

在客户端中执行：

```c++
int main() {
    Canvas canvas;
    canvas.addShape(std::make_shared<Circle>());
    canvas.addShape(std::make_shared<Rectangle>());

    canvas.drawShapes(); // 输出: Drawing a Circle, Drawing a Rectangle

    return 0;
}
```

# 25、桥接模式

## 概念

桥接模式（Bridge Pattern）是一种结构型设计模式，它通过将抽象部分与实现部分分离，使得两者可以独立变化。该模式旨在避免在抽象类和具体实现类之间的强耦合关系，提供更大的灵活性和可扩展性。

## 主要组成

**抽象类（Abstraction）**：定义了高层操作的接口，通常持有一个指向实现类的引用。

**扩展抽象类（Refined Abstraction）**：继承自抽象类，扩展其功能。

**实现类接口（Implementor）**：定义了实现类的接口，但不一定要与抽象类的接口一致。

**具体实现类（Concrete Implementor）**：实现了实现类接口，提供具体的实现。

## 示例

下面是一个简单的桥接模式的示例，用于绘图应用程序，展示不同的形状和不同的颜色。本例中将抽象类(shape)和实现类(color)分离开来了。

定义实现类接口：定义了颜色的接口，具体颜色类（如红色和蓝色）将实现这一接口。

```c++
// 实现类接口
class Color {
public:
    virtual ~Color() {}
    virtual void applyColor() = 0;
};
```

定义具体实现类：实现了颜色接口，提供具体的颜色应用方法。

```c++
// 具体实现类：红色
class Red : public Color {
public:
    void applyColor() override {
        std::cout << "Red color applied." << std::endl;
    }
};

// 具体实现类：蓝色
class Blue : public Color {
public:
    void applyColor() override {
        std::cout << "Blue color applied." << std::endl;
    }
};
```

定义抽象类：定义了形状的接口，并持有一个颜色的引用。

```c++
// 抽象类
class Shape {
public:
    Shape(std::shared_ptr<Color> color) : color(color) {}
    virtual ~Shape() {}
    virtual void draw() = 0;

protected:
    std::shared_ptr<Color> color; // 持有一个实现类的引用
};
```

定义扩展抽象类：继承自 `Shape`，实现具体的绘制方法，调用颜色的实现。

```c++
// 扩展抽象类：圆形
class Circle : public Shape {
public:
    Circle(std::shared_ptr<Color> color) : Shape(color) {}

    void draw() override {
        std::cout << "Drawing Circle: ";
        color->applyColor(); // 调用具体实现
    }
};

// 扩展抽象类：矩形
class Rectangle : public Shape {
public:
    Rectangle(std::shared_ptr<Color> color) : Shape(color) {}

    void draw() override {
        std::cout << "Drawing Rectangle: ";
        color->applyColor(); // 调用具体实现
    }
};
```

在客户端中执行：

```c++
// 使用示例
int main() {
    std::shared_ptr<Color> redColor = std::make_shared<Red>();
    std::shared_ptr<Color> blueColor = std::make_shared<Blue>();

    Shape* circle = new Circle(redColor);
    Shape* rectangle = new Rectangle(blueColor);

    circle->draw();      // 输出: Drawing Circle: Red color applied.
    rectangle->draw();   // 输出: Drawing Rectangle: Blue color applied.

    delete circle;
    delete rectangle;

    return 0;
}
```

即增加shape类的时候不用考虑color的具体实现，增加color类的时候也不用考虑shape类。

# 26、命令模式

## 概念

命令模式（Command Pattern）是一种行为设计模式，它把请求封装为对象，提供了一种灵活的方式来处理操作请求。它使得请求的调用、排队、日志记录和撤销操作变得更加简单和清晰。通过使用命令模式，可以将命令的执行与请求的发起者分离，提高了系统的可扩展性和可维护性。

## 主要组成部分

**命令接口（Command）**：定义一个执行操作的接口。

**具体命令（Concrete Command）**：实现命令接口，定义与接收者之间的绑定，调用接收者的相应操作。

**接收者（Receiver）**：实际执行操作的对象。命令模式通过接收者来完成请求。

**调用者（Invoker）**：持有命令对象，并调用其执行方法。

## 示例

以下是一个简单的命令模式示例，演示了如何使用命令模式来实现一个简单的计算器功能。

定义命令接口：定义了 `execute()` 方法，所有具体命令类都必须实现这个方法。

```c++
// 命令接口
class Command {
public:
    virtual void execute() = 0;
    virtual ~Command() = default;
};
```

定义接收者类：具有执行操作的具体方法，如 `add()` 和 `subtract()`，用于修改状态。

```c++
// 接收者类
class Calculator {
public:
    void add(int value) {
        total += value;
        std::cout << "Added " << value << ", total is now " << total << std::endl;
    }

    void subtract(int value) {
        total -= value;
        std::cout << "Subtracted " << value << ", total is now " << total << std::endl;
    }

private:
    int total = 0; // 计算总和
};
```

定义具体命令：`AddCommand` 和 `SubtractCommand` 是具体命令的实现，它们封装了对接收者的操作。同时在构造函数中接收一个 `Calculator` 实例和要执行的值，并在 `execute()` 方法中调用相应的接收者方法。

```c++
// 具体命令：加法
class AddCommand : public Command {
public:
    AddCommand(Calculator* calculator, int value) : calculator(calculator), value(value) {}

    void execute() override {
        calculator->add(value);
    }

private:
    Calculator* calculator;
    int value;
};

// 具体命令：减法
class SubtractCommand : public Command {
public:
    SubtractCommand(Calculator* calculator, int value) : calculator(calculator), value(value) {}

    void execute() override {
        calculator->subtract(value);
    }

private:
    Calculator* calculator;
    int value;
};
```

定义调用者类：`Invoker` 类负责存储和执行命令。它使用 `storeCommand()` 方法存储命令，并使用 `executeCommands()` 方法执行所有存储的命令。

```c++
// 调用者类
class Invoker {
public:
    void storeCommand(std::unique_ptr<Command> command) {
        commands.push_back(std::move(command));
    }

    void executeCommands() {
        for (const auto& command : commands) {
            command->execute();
        }
        commands.clear(); // 执行后清空命令
    }

private:
    std::vector<std::unique_ptr<Command>> commands;
};
```

在客户端中执行：

```c++
// 客户端
int main() {
    Calculator calculator;
    Invoker invoker;

    // 创建命令
    invoker.storeCommand(std::make_unique<AddCommand>(&calculator, 10));
    invoker.storeCommand(std::make_unique<SubtractCommand>(&calculator, 5));
    invoker.storeCommand(std::make_unique<AddCommand>(&calculator, 20));

    // 执行命令
    invoker.executeCommands();

    return 0;
}
```

# 27、职责链模式

## 概念

职责链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许将请求的发送者和接收者解耦。通过将多个处理对象连接成一条链，接收者可以动态地处理请求。每个处理对象都有机会处理请求，或者将请求传递给链中的下一个处理对象。这样可以避免请求的发送者与具体的处理者之间的紧耦合关系。

## 主要组成

**Handler（处理者）**: 定义一个处理请求的接口，并实现默认的处理行为。可以选择将请求传递给下一个处理者。

**ConcreteHandler（具体处理者）**: 实现 Handler 接口，处理请求。如果不能处理请求，则将其传递给下一个处理者。

## 示例

假设我们有一个处理请求的场景，其中请求的级别可以是“低”、“中”、“高”，我们将根据请求的级别将其传递给不同的处理者。

创建抽象处理者：这是一个抽象类，定义了处理请求的接口 `handleRequest`，并包含一个指向下一个处理者的指针 `nextHandler`。

```c++
// 抽象处理者
class Handler {
protected:
    Handler* nextHandler; // 下一个处理者

public:
    Handler() : nextHandler(nullptr) {}

    void setNextHandler(Handler* handler) {
        nextHandler = handler; // 设置下一个处理者
    }

    virtual void handleRequest(int level) = 0; // 处理请求的接口
};
```

创建具体处理者：`LowLevelHandler`、`MediumLevelHandler` 和 `HighLevelHandler` 是具体的处理者类，分别处理不同级别的请求。每个处理者在 `handleRequest` 方法中检查请求的级别，如果可以处理，则执行相应的操作；如果不能处理，则将请求传递给下一个处理者。

```c++
// 具体处理者：低级别请求处理者
class LowLevelHandler : public Handler {
public:
    void handleRequest(int level) override {
        if (level == 1) {
            std::cout << "LowLevelHandler: Handling low level request." << std::endl;
        } else if (nextHandler) {
            nextHandler->handleRequest(level); // 传递给下一个处理者
        }
    }
};

// 具体处理者：中级别请求处理者
class MediumLevelHandler : public Handler {
public:
    void handleRequest(int level) override {
        if (level == 2) {
            std::cout << "MediumLevelHandler: Handling medium level request." << std::endl;
        } else if (nextHandler) {
            nextHandler->handleRequest(level); // 传递给下一个处理者
        }
    }
};

// 具体处理者：高级别请求处理者
class HighLevelHandler : public Handler {
public:
    void handleRequest(int level) override {
        if (level == 3) {
            std::cout << "HighLevelHandler: Handling high level request." << std::endl;
        } else if (nextHandler) {
            nextHandler->handleRequest(level); // 传递给下一个处理者
        }
    }
};
```

在客户端中执行：在 `main` 函数中，我们创建了处理者对象，并设置了职责链。然后，客户端发送不同级别的请求，处理者根据请求的级别进行处理。

```c++
// 客户端
int main() {
    // 创建处理者
    LowLevelHandler* lowHandler = new LowLevelHandler();
    MediumLevelHandler* mediumHandler = new MediumLevelHandler();
    HighLevelHandler* highHandler = new HighLevelHandler();

    // 设置职责链
    lowHandler->setNextHandler(mediumHandler);
    mediumHandler->setNextHandler(highHandler);

    // 客户端请求
    std::cout << "Client: Sending request with level 1." << std::endl;
    lowHandler->handleRequest(1); // 处理低级别请求

    std::cout << "Client: Sending request with level 2." << std::endl;
    lowHandler->handleRequest(2); // 处理中级别请求

    std::cout << "Client: Sending request with level 3." << std::endl;
    lowHandler->handleRequest(3); // 处理高级别请求

    std::cout << "Client: Sending request with level 4." << std::endl;
    lowHandler->handleRequest(4); // 处理未被处理的请求

    // 清理内存
    delete lowHandler;
    delete mediumHandler;
    delete highHandler;

    return 0;
}
```

# 28、中介者模式

## 概念

中介者模式（Mediator Pattern）是一种行为设计模式，它通过引入一个中介者对象来减少多个对象之间的直接通信，从而促进松耦合。中介者负责协调这些对象之间的交互，避免它们直接相互依赖。

## 优点

**降低耦合**：对象之间不直接引用，而是通过中介者进行交互。

**易于扩展**：增加新的同事类时，只需修改中介者，而无需修改其他类。

**集中控制**：中介者集中处理对象之间的交互逻辑，简化了对象的职责。

## 示例

下面是一个使用中介者模式的简单示例，模拟一个聊天室的场景，参与者通过中介者进行消息传递。

定义中介者接口，约定了中介者应有的方法，例如 `send` 方法。中介者负责协调同事对象之间的交互。

```c++
// 中介者接口
class Mediator {
public:
    virtual void send(const std::string& message, class Colleague* colleague) = 0;
};
```

定义同事类的基类，持有一个指向中介者的引用。这个类声明了接收消息的接口 `receive`，具体的同事类需要实现这个接口。

```c++
class Colleague {
protected:
    Mediator* mediator;
public:
    Colleague(Mediator* m) : mediator(m) {}
    virtual void receive(const std::string& message) = 0;
};
```

实现具体的同事类：实现 `Colleague` 类，代表聊天室中的用户。该类包含用户的名称和发送和接收消息的逻辑。

```c++
class User : public Colleague {
    std::string name;
public:
    User(const std::string& name, Mediator* m) : Colleague(m), name(name) {}

    void send(const std::string& message) {
        std::cout << name << " sends: " << message << std::endl;
        mediator->send(message, this);
    }

    void receive(const std::string& message) override {
        std::cout << name << " receives: " << message << std::endl;
    }
};
```

实现具体的中介者类：实现 `Mediator` 接口，具体的中介者类，负责用户之间的消息传递。

```c++
class ChatRoom : public Mediator {
    std::vector<Colleague*> users;
public:
    void addUser(Colleague* user) {
        users.push_back(user);
    }

    void send(const std::string& message, Colleague* sender) override {
        for (auto user : users) {
            // 不发送给发送者自己
            if (user != sender) {
                user->receive(message);
            }
        }
    }
};
```

在客户端中调用：

```c++
int main() {
    ChatRoom chatRoom;

    User user1("Alice", &chatRoom);
    User user2("Bob", &chatRoom);
    
    chatRoom.addUser(&user1);
    chatRoom.addUser(&user2);

    user1.send("Hello, everyone!");
    user2.send("Hi Alice!");

    return 0;
}
```

输出为：

```
Alice sends: Hello, everyone!
Bob receives: Hello, everyone!
Bob sends: Hi Alice!
Alice receives: Hi Alice!
```

# 29、享元模式

## 概念

享元模式（Flyweight Pattern）是一种结构型设计模式，旨在通过共享对象来减少内存使用和提高性能。这种模式特别适用于大量细粒度对象的场景，能够显著减少内存消耗。

## 主要组成

**享元（Flyweight）**：是一个可以被共享的对象，它的状态分为两部分：

- **内部状态**：享元对象的状态，可以被共享的部分。
- **外部状态**：享元对象的状态，依赖于具体的上下文，不可共享。

**享元工厂（Flyweight Factory）**：负责创建和管理享元对象。它可以确保共享对象的唯一性和有效性。

## 示例

以下是一个简单的享元模式的示例，用于表示字符的字体风格。

创建享元类：包含内部状态（字符和字体）。`display` 方法用于展示字符信息。

```c++
// 享元类
class Character {
public:
    Character(char c, const std::string& font) : c(c), font(font) {}

    void display(int size) {
        std::cout << "Character: " << c << ", Font: " << font << ", Size: " << size << std::endl;
    }

private:
    char c;          // 字符
    std::string font; // 字体
};
```

创建享元工厂：享元工厂，负责创建和管理 `Character` 对象。使用 `unordered_map` 来存储已经创建的字符对象，确保相同字符和字体的对象只被创建一次。

```c++
// 享元工厂
class CharacterFactory {
public:
    Character* getCharacter(char c, const std::string& font) {
        std::string key = std::string(1, c) + font;
        if (characters.find(key) == characters.end()) {
            characters[key] = new Character(c, font);
        }
        return characters[key];
    }

    ~CharacterFactory() {
        for (auto& pair : characters) {
            delete pair.second;
        }
    }

private:
    std::unordered_map<std::string, Character*> characters; // 存储共享的字符
};
```

在客户端中执行：

```c++
// 客户端代码
int main() {
    CharacterFactory factory;

    Character* a1 = factory.getCharacter('A', "Arial");
    a1->display(12);

    Character* a2 = factory.getCharacter('A', "Arial");
    a2->display(14);

    Character* b1 = factory.getCharacter('B', "Times New Roman");
    b1->display(12);

    Character* b2 = factory.getCharacter('B', "Times New Roman");
    b2->display(16);

    // a1 和 a2 实际上是同一个对象
    std::cout << "Are a1 and a2 the same object? " << (a1 == a2) << std::endl;

    // b1 和 b2 实际上是同一个对象
    std::cout << "Are b1 and b2 the same object? " << (b1 == b2) << std::endl;

    return 0;
}
```

# 30、解释器模式

## 概念

解释器模式（Interpreter Pattern）是一种设计模式，属于行为型模式。它的主要目的是为特定的语言或表达式定义一个语法，并提供一个解释器来解释这些表达式。解释器模式通常用于构建一个解释器，能够解析和执行特定的语言或表达式。

## 主要组成

**抽象表达式（Abstract Expression）**: 定义一个接口，用于解释文法中的所有表达式。

**终结符表达式（Terminal Expression）**: 实现抽象表达式接口，表示文法中的基本元素。

**非终结符表达式（Non-terminal Expression）**: 也实现抽象表达式接口，表示文法中的组合元素。

**上下文（Context）**: 存储解释器所需的信息，通常是一些全局信息。

## 示例

使用解释器模式来解析和计算简单的数学表达式（如加法和减法）。

类似于二叉树结构，叶子节点是数字(终结符表达式)，根节点是运算符(非终结符表达式)。

定义抽象表达式：`Expression` 类是所有表达式的基类，定义了一个 `interpret` 方法。

```c++
// 抽象表达式
class Expression {
public:
    virtual int interpret(std::map<std::string, int>& context) = 0;
};
```

定义终结符表达式：`Number` 类表示数字，直接返回其值。

```c++
// 终结符表达式：数字
class Number : public Expression {
private:
    int number;
public:
    Number(int num) : number(num) {}
    
    int interpret(std::map<std::string, int>& context) override {
        return number;
    }
};
```

定义非终结符表达式：`Add` 和 `Subtract` 类分别表示加法和减法操作，它们包含左右两个表达式，并实现 `interpret` 方法来计算结果。

```c++
// 非终结符表达式：加法
class Add : public Expression {
private:
    std::shared_ptr<Expression> left;
    std::shared_ptr<Expression> right;
public:
    Add(std::shared_ptr<Expression> l, std::shared_ptr<Expression> r) : left(l), right(r) {}
    
    int interpret(std::map<std::string, int>& context) override {
        return left->interpret(context) + right->interpret(context);
    }
};

// 非终结符表达式：减法
class Subtract : public Expression {
private:
    std::shared_ptr<Expression> left;
    std::shared_ptr<Expression> right;
public:
    Subtract(std::shared_ptr<Expression> l, std::shared_ptr<Expression> r) : left(l), right(r) {}
    
    int interpret(std::map<std::string, int>& context) override {
        return left->interpret(context) - right->interpret(context);
    }
};
```

在客户端中执行：

```c++
// 客户端代码
int main() {
    // 表达式：5 + 3 - 2
    std::shared_ptr<Expression> five = std::make_shared<Number>(5);
    std::shared_ptr<Expression> three = std::make_shared<Number>(3);
    std::shared_ptr<Expression> two = std::make_shared<Number>(2);
    
    std::shared_ptr<Expression> addExpr = std::make_shared<Add>(five, three);
    std::shared_ptr<Expression> subtractExpr = std::make_shared<Subtract>(addExpr, two);
    
    std::map<std::string, int> context; // 在这个简单示例中，未使用上下文
    int result = subtractExpr->interpret(context);
    
    std::cout << "Result: " << result << std::endl; // 输出结果：6

    return 0;
}
```

# 31、访问者模式

## 概念

访问者模式（Visitor Pattern）是一种行为型设计模式，它允许你在不修改现有对象结构的情况下，向该结构中添加新的操作。通过将操作封装在访问者对象中，访问者模式使得你可以在多个类上执行相同的操作，而不需要在每个类中实现这些操作。

## 主要组成

**访问者接口（Visitor Interface）**: 定义访问者的接口，声明对每种元素的访问方法。

**具体访问者（Concrete Visitor）**: 实现访问者接口，定义对每种元素的具体操作。

**元素接口（Element Interface）**: 定义接受访问者的接口，通常包含一个 `accept` 方法。

**具体元素（Concrete Element）**: 实现元素接口，定义具体的元素对象。

**对象结构（Object Structure）**: 通常是一个集合，包含多个具体元素，允许访问者访问这些元素。

## 优点

**分离操作和对象结构**: 访问者模式将操作与对象结构分离，使得可以在不修改对象结构的情况下增加新的操作。

**易于扩展**: 新的操作可以通过添加新的访问者类来实现，而不需要修改现有的元素类。

**集中操作**: 所有操作都集中在访问者中，便于管理和维护。

## 缺点

**增加了系统的复杂性**: 访问者模式引入了新的类和接口，可能会使系统变得更加复杂。

**不适合频繁变化的对象结构**: 如果对象结构经常变化，访问者模式可能会导致频繁修改访问者的代码。

## 示例

使用访问者模式来计算不同形状图形的面积。

将Circle类和Rectangle类前向声明：

```c++
// 前向声明
class Circle;
class Rectangle;
```

定义访问者接口：`ShapeVisitor` 定义了访问者的接口，声明了对 `Circle` 和 `Rectangle` 的访问方法。

```c++
// 访问者接口
class ShapeVisitor {
public:
    virtual void visit(Circle* circle) = 0;
    virtual void visit(Rectangle* rectangle) = 0;
};
```

定义元素接口：`Shape` 定义了接受访问者的接口，包含 `accept` 方法。

```c++
// 元素接口
class Shape {
public:
    virtual void accept(ShapeVisitor* visitor) = 0;
};
```

定义具体元素：`Circle` 和 `Rectangle` 实现了 `Shape` 接口，并在 `accept` 方法中调用访问者的相应方法。

```c++
// 具体元素：圆形
class Circle : public Shape {
public:
    void accept(ShapeVisitor* visitor) override {
        visitor->visit(this);
    }
    
    double getRadius() const {
        return 5.0; // 假设半径为 5
    }
};

// 具体元素：矩形
class Rectangle : public Shape {
public:
    void accept(ShapeVisitor* visitor) override {
        visitor->visit(this);
    }
    
    double getWidth() const {
        return 4.0; // 假设宽度为 4
    }
    
    double getHeight() const {
        return 6.0; // 假设高度为 6
    }
};
```

定义具体访问者：`AreaCalculator` 实现了 `ShapeVisitor` 接口，定义了计算每种形状面积的具体操作。

```c++
// 具体访问者：计算面积
class AreaCalculator : public ShapeVisitor {
public:
    void visit(Circle* circle) override {
        double area = 3.14159 * circle->getRadius() * circle->getRadius();
        std::cout << "Circle area: " << area << std::endl;
    }
    
    void visit(Rectangle* rectangle) override {
        double area = rectangle->getWidth() * rectangle->getHeight();
        std::cout << "Rectangle area: " << area << std::endl;
    }
};
```

在客户端中执行：在 `main` 函数中，创建了一个形状的集合，并使用 `AreaCalculator` 访问每个形状，计算并输出其面积。

```c++
// 客户端代码
int main() {
    std::vector<std::shared_ptr<Shape>> shapes;
    shapes.push_back(std::make_shared<Circle>());
    shapes.push_back(std::make_shared<Rectangle>());
    
    AreaCalculator areaCalculator;
    
    for (const auto& shape : shapes) {
        shape->accept(&areaCalculator); // 访问每个形状并计算面积
    }
    
    return 0;
}
```

完结撒花🌹🌹🌹
